/*
 * This file was auto-generated by speedy-antlr-tool v1.1.0
 *  https://github.com/amykyta3/speedy-antlr-tool
 */

#define PY_SSIZE_T_CLEAN
#include <Python.h>

#include <cstring>

#include "antlr4-runtime.h"
#include "KotlinLexer.h"
#include "KotlinParser.h"
#include "speedy_antlr.h"

#include "sa_kotlin_translator.h"

/*
 * Python function prototype:
 *  do_parse(
 *      parser_cls:antlr4.Parser,
 *      stream:antlr4.InputStream,
 *      entry_rule_name:str,
 *      sa_err_listener:SA_ErrorListener
 *  )
 */
PyObject* do_parse(PyObject *self, PyObject *args) {
    PyObject *strdata = NULL;
    PyObject *result = NULL;
    PyObject *token_module = NULL;

    try {
        // Get args
        PyObject *parser_cls = NULL;
        PyObject *stream = NULL;
        const char *entry_rule_name = NULL;
        PyObject *sa_err_listener = NULL;
        if(!PyArg_ParseTuple(args,
            "OOsO:do_parse",
            &parser_cls, &stream, &entry_rule_name, &sa_err_listener
        )) {
            return NULL;
        }

        // Extract input stream's string
        const char *cstrdata;
        Py_ssize_t bufsize;
        strdata = PyObject_GetAttrString(stream, "strdata");
        if(!strdata) throw speedy_antlr::PythonException();
        cstrdata = PyUnicode_AsUTF8AndSize(strdata, &bufsize);
        if(!cstrdata) throw speedy_antlr::PythonException();

        // Create an antlr InputStream object
        antlr4::ANTLRInputStream cpp_stream(cstrdata, bufsize);

        // in case error listener is overridden
        token_module = PyImport_ImportModule("antlr4.Token");
        if(!token_module) throw speedy_antlr::PythonException();
        speedy_antlr::Translator translator(parser_cls, stream);
        speedy_antlr::ErrorTranslatorListener err_listener(&translator, sa_err_listener);

        // Lex
        KotlinLexer lexer(&cpp_stream);
        if(sa_err_listener != Py_None){
            lexer.removeErrorListeners();
            lexer.addErrorListener(&err_listener);
        }
        antlr4::CommonTokenStream token_stream(&lexer);
        token_stream.fill();

        // Parse
        KotlinParser parser(&token_stream);
        if(sa_err_listener != Py_None){
            parser.removeErrorListeners();
            parser.addErrorListener(&err_listener);
        }
        antlr4::tree::ParseTree *parse_tree;
        if(!strcmp(entry_rule_name, "kotlinFile")){
            parse_tree = parser.kotlinFile();

        } else if(!strcmp(entry_rule_name, "script")){
            parse_tree = parser.script();

        } else if(!strcmp(entry_rule_name, "shebangLine")){
            parse_tree = parser.shebangLine();

        } else if(!strcmp(entry_rule_name, "fileAnnotation")){
            parse_tree = parser.fileAnnotation();

        } else if(!strcmp(entry_rule_name, "packageHeader")){
            parse_tree = parser.packageHeader();

        } else if(!strcmp(entry_rule_name, "importList")){
            parse_tree = parser.importList();

        } else if(!strcmp(entry_rule_name, "importHeader")){
            parse_tree = parser.importHeader();

        } else if(!strcmp(entry_rule_name, "importAlias")){
            parse_tree = parser.importAlias();

        } else if(!strcmp(entry_rule_name, "topLevelObject")){
            parse_tree = parser.topLevelObject();

        } else if(!strcmp(entry_rule_name, "typeAlias")){
            parse_tree = parser.typeAlias();

        } else if(!strcmp(entry_rule_name, "declaration")){
            parse_tree = parser.declaration();

        } else if(!strcmp(entry_rule_name, "classDeclaration")){
            parse_tree = parser.classDeclaration();

        } else if(!strcmp(entry_rule_name, "primaryConstructor")){
            parse_tree = parser.primaryConstructor();

        } else if(!strcmp(entry_rule_name, "classBody")){
            parse_tree = parser.classBody();

        } else if(!strcmp(entry_rule_name, "classParameters")){
            parse_tree = parser.classParameters();

        } else if(!strcmp(entry_rule_name, "classParameter")){
            parse_tree = parser.classParameter();

        } else if(!strcmp(entry_rule_name, "delegationSpecifiers")){
            parse_tree = parser.delegationSpecifiers();

        } else if(!strcmp(entry_rule_name, "delegationSpecifier")){
            parse_tree = parser.delegationSpecifier();

        } else if(!strcmp(entry_rule_name, "constructorInvocation")){
            parse_tree = parser.constructorInvocation();

        } else if(!strcmp(entry_rule_name, "annotatedDelegationSpecifier")){
            parse_tree = parser.annotatedDelegationSpecifier();

        } else if(!strcmp(entry_rule_name, "explicitDelegation")){
            parse_tree = parser.explicitDelegation();

        } else if(!strcmp(entry_rule_name, "typeParameters")){
            parse_tree = parser.typeParameters();

        } else if(!strcmp(entry_rule_name, "typeParameter")){
            parse_tree = parser.typeParameter();

        } else if(!strcmp(entry_rule_name, "typeConstraints")){
            parse_tree = parser.typeConstraints();

        } else if(!strcmp(entry_rule_name, "typeConstraint")){
            parse_tree = parser.typeConstraint();

        } else if(!strcmp(entry_rule_name, "classMemberDeclarations")){
            parse_tree = parser.classMemberDeclarations();

        } else if(!strcmp(entry_rule_name, "classMemberDeclaration")){
            parse_tree = parser.classMemberDeclaration();

        } else if(!strcmp(entry_rule_name, "anonymousInitializer")){
            parse_tree = parser.anonymousInitializer();

        } else if(!strcmp(entry_rule_name, "companionObject")){
            parse_tree = parser.companionObject();

        } else if(!strcmp(entry_rule_name, "functionValueParameters")){
            parse_tree = parser.functionValueParameters();

        } else if(!strcmp(entry_rule_name, "functionValueParameter")){
            parse_tree = parser.functionValueParameter();

        } else if(!strcmp(entry_rule_name, "functionDeclaration")){
            parse_tree = parser.functionDeclaration();

        } else if(!strcmp(entry_rule_name, "functionBody")){
            parse_tree = parser.functionBody();

        } else if(!strcmp(entry_rule_name, "variableDeclaration")){
            parse_tree = parser.variableDeclaration();

        } else if(!strcmp(entry_rule_name, "multiVariableDeclaration")){
            parse_tree = parser.multiVariableDeclaration();

        } else if(!strcmp(entry_rule_name, "propertyDeclaration")){
            parse_tree = parser.propertyDeclaration();

        } else if(!strcmp(entry_rule_name, "propertyDelegate")){
            parse_tree = parser.propertyDelegate();

        } else if(!strcmp(entry_rule_name, "getter")){
            parse_tree = parser.getter();

        } else if(!strcmp(entry_rule_name, "setter")){
            parse_tree = parser.setter();

        } else if(!strcmp(entry_rule_name, "parametersWithOptionalType")){
            parse_tree = parser.parametersWithOptionalType();

        } else if(!strcmp(entry_rule_name, "functionValueParameterWithOptionalType")){
            parse_tree = parser.functionValueParameterWithOptionalType();

        } else if(!strcmp(entry_rule_name, "parameterWithOptionalType")){
            parse_tree = parser.parameterWithOptionalType();

        } else if(!strcmp(entry_rule_name, "parameter")){
            parse_tree = parser.parameter();

        } else if(!strcmp(entry_rule_name, "objectDeclaration")){
            parse_tree = parser.objectDeclaration();

        } else if(!strcmp(entry_rule_name, "secondaryConstructor")){
            parse_tree = parser.secondaryConstructor();

        } else if(!strcmp(entry_rule_name, "constructorDelegationCall")){
            parse_tree = parser.constructorDelegationCall();

        } else if(!strcmp(entry_rule_name, "enumClassBody")){
            parse_tree = parser.enumClassBody();

        } else if(!strcmp(entry_rule_name, "enumEntries")){
            parse_tree = parser.enumEntries();

        } else if(!strcmp(entry_rule_name, "enumEntry")){
            parse_tree = parser.enumEntry();

        } else if(!strcmp(entry_rule_name, "type")){
            parse_tree = parser.type();

        } else if(!strcmp(entry_rule_name, "typeReference")){
            parse_tree = parser.typeReference();

        } else if(!strcmp(entry_rule_name, "nullableType")){
            parse_tree = parser.nullableType();

        } else if(!strcmp(entry_rule_name, "quest")){
            parse_tree = parser.quest();

        } else if(!strcmp(entry_rule_name, "userType")){
            parse_tree = parser.userType();

        } else if(!strcmp(entry_rule_name, "simpleUserType")){
            parse_tree = parser.simpleUserType();

        } else if(!strcmp(entry_rule_name, "typeProjection")){
            parse_tree = parser.typeProjection();

        } else if(!strcmp(entry_rule_name, "typeProjectionModifiers")){
            parse_tree = parser.typeProjectionModifiers();

        } else if(!strcmp(entry_rule_name, "typeProjectionModifier")){
            parse_tree = parser.typeProjectionModifier();

        } else if(!strcmp(entry_rule_name, "functionType")){
            parse_tree = parser.functionType();

        } else if(!strcmp(entry_rule_name, "functionTypeParameters")){
            parse_tree = parser.functionTypeParameters();

        } else if(!strcmp(entry_rule_name, "parenthesizedType")){
            parse_tree = parser.parenthesizedType();

        } else if(!strcmp(entry_rule_name, "receiverType")){
            parse_tree = parser.receiverType();

        } else if(!strcmp(entry_rule_name, "parenthesizedUserType")){
            parse_tree = parser.parenthesizedUserType();

        } else if(!strcmp(entry_rule_name, "statements")){
            parse_tree = parser.statements();

        } else if(!strcmp(entry_rule_name, "statement")){
            parse_tree = parser.statement();

        } else if(!strcmp(entry_rule_name, "label")){
            parse_tree = parser.label();

        } else if(!strcmp(entry_rule_name, "controlStructureBody")){
            parse_tree = parser.controlStructureBody();

        } else if(!strcmp(entry_rule_name, "block")){
            parse_tree = parser.block();

        } else if(!strcmp(entry_rule_name, "loopStatement")){
            parse_tree = parser.loopStatement();

        } else if(!strcmp(entry_rule_name, "forStatement")){
            parse_tree = parser.forStatement();

        } else if(!strcmp(entry_rule_name, "whileStatement")){
            parse_tree = parser.whileStatement();

        } else if(!strcmp(entry_rule_name, "doWhileStatement")){
            parse_tree = parser.doWhileStatement();

        } else if(!strcmp(entry_rule_name, "assignment")){
            parse_tree = parser.assignment();

        } else if(!strcmp(entry_rule_name, "semi")){
            parse_tree = parser.semi();

        } else if(!strcmp(entry_rule_name, "semis")){
            parse_tree = parser.semis();

        } else if(!strcmp(entry_rule_name, "expression")){
            parse_tree = parser.expression();

        } else if(!strcmp(entry_rule_name, "disjunction")){
            parse_tree = parser.disjunction();

        } else if(!strcmp(entry_rule_name, "conjunction")){
            parse_tree = parser.conjunction();

        } else if(!strcmp(entry_rule_name, "equality")){
            parse_tree = parser.equality();

        } else if(!strcmp(entry_rule_name, "comparison")){
            parse_tree = parser.comparison();

        } else if(!strcmp(entry_rule_name, "genericCallLikeComparison")){
            parse_tree = parser.genericCallLikeComparison();

        } else if(!strcmp(entry_rule_name, "infixOperation")){
            parse_tree = parser.infixOperation();

        } else if(!strcmp(entry_rule_name, "elvisExpression")){
            parse_tree = parser.elvisExpression();

        } else if(!strcmp(entry_rule_name, "elvis")){
            parse_tree = parser.elvis();

        } else if(!strcmp(entry_rule_name, "infixFunctionCall")){
            parse_tree = parser.infixFunctionCall();

        } else if(!strcmp(entry_rule_name, "rangeExpression")){
            parse_tree = parser.rangeExpression();

        } else if(!strcmp(entry_rule_name, "additiveExpression")){
            parse_tree = parser.additiveExpression();

        } else if(!strcmp(entry_rule_name, "multiplicativeExpression")){
            parse_tree = parser.multiplicativeExpression();

        } else if(!strcmp(entry_rule_name, "asExpression")){
            parse_tree = parser.asExpression();

        } else if(!strcmp(entry_rule_name, "prefixUnaryExpression")){
            parse_tree = parser.prefixUnaryExpression();

        } else if(!strcmp(entry_rule_name, "unaryPrefix")){
            parse_tree = parser.unaryPrefix();

        } else if(!strcmp(entry_rule_name, "postfixUnaryExpression")){
            parse_tree = parser.postfixUnaryExpression();

        } else if(!strcmp(entry_rule_name, "postfixUnarySuffix")){
            parse_tree = parser.postfixUnarySuffix();

        } else if(!strcmp(entry_rule_name, "directlyAssignableExpression")){
            parse_tree = parser.directlyAssignableExpression();

        } else if(!strcmp(entry_rule_name, "parenthesizedDirectlyAssignableExpression")){
            parse_tree = parser.parenthesizedDirectlyAssignableExpression();

        } else if(!strcmp(entry_rule_name, "assignableExpression")){
            parse_tree = parser.assignableExpression();

        } else if(!strcmp(entry_rule_name, "parenthesizedAssignableExpression")){
            parse_tree = parser.parenthesizedAssignableExpression();

        } else if(!strcmp(entry_rule_name, "assignableSuffix")){
            parse_tree = parser.assignableSuffix();

        } else if(!strcmp(entry_rule_name, "indexingSuffix")){
            parse_tree = parser.indexingSuffix();

        } else if(!strcmp(entry_rule_name, "navigationSuffix")){
            parse_tree = parser.navigationSuffix();

        } else if(!strcmp(entry_rule_name, "callSuffix")){
            parse_tree = parser.callSuffix();

        } else if(!strcmp(entry_rule_name, "annotatedLambda")){
            parse_tree = parser.annotatedLambda();

        } else if(!strcmp(entry_rule_name, "typeArguments")){
            parse_tree = parser.typeArguments();

        } else if(!strcmp(entry_rule_name, "valueArguments")){
            parse_tree = parser.valueArguments();

        } else if(!strcmp(entry_rule_name, "valueArgument")){
            parse_tree = parser.valueArgument();

        } else if(!strcmp(entry_rule_name, "primaryExpression")){
            parse_tree = parser.primaryExpression();

        } else if(!strcmp(entry_rule_name, "parenthesizedExpression")){
            parse_tree = parser.parenthesizedExpression();

        } else if(!strcmp(entry_rule_name, "collectionLiteral")){
            parse_tree = parser.collectionLiteral();

        } else if(!strcmp(entry_rule_name, "literalConstant")){
            parse_tree = parser.literalConstant();

        } else if(!strcmp(entry_rule_name, "stringLiteral")){
            parse_tree = parser.stringLiteral();

        } else if(!strcmp(entry_rule_name, "lineStringLiteral")){
            parse_tree = parser.lineStringLiteral();

        } else if(!strcmp(entry_rule_name, "multiLineStringLiteral")){
            parse_tree = parser.multiLineStringLiteral();

        } else if(!strcmp(entry_rule_name, "lineStringContent")){
            parse_tree = parser.lineStringContent();

        } else if(!strcmp(entry_rule_name, "lineStringExpression")){
            parse_tree = parser.lineStringExpression();

        } else if(!strcmp(entry_rule_name, "multiLineStringContent")){
            parse_tree = parser.multiLineStringContent();

        } else if(!strcmp(entry_rule_name, "multiLineStringExpression")){
            parse_tree = parser.multiLineStringExpression();

        } else if(!strcmp(entry_rule_name, "lambdaLiteral")){
            parse_tree = parser.lambdaLiteral();

        } else if(!strcmp(entry_rule_name, "lambdaParameters")){
            parse_tree = parser.lambdaParameters();

        } else if(!strcmp(entry_rule_name, "lambdaParameter")){
            parse_tree = parser.lambdaParameter();

        } else if(!strcmp(entry_rule_name, "anonymousFunction")){
            parse_tree = parser.anonymousFunction();

        } else if(!strcmp(entry_rule_name, "functionLiteral")){
            parse_tree = parser.functionLiteral();

        } else if(!strcmp(entry_rule_name, "objectLiteral")){
            parse_tree = parser.objectLiteral();

        } else if(!strcmp(entry_rule_name, "thisExpression")){
            parse_tree = parser.thisExpression();

        } else if(!strcmp(entry_rule_name, "superExpression")){
            parse_tree = parser.superExpression();

        } else if(!strcmp(entry_rule_name, "ifExpression")){
            parse_tree = parser.ifExpression();

        } else if(!strcmp(entry_rule_name, "whenSubject")){
            parse_tree = parser.whenSubject();

        } else if(!strcmp(entry_rule_name, "whenExpression")){
            parse_tree = parser.whenExpression();

        } else if(!strcmp(entry_rule_name, "whenEntry")){
            parse_tree = parser.whenEntry();

        } else if(!strcmp(entry_rule_name, "whenCondition")){
            parse_tree = parser.whenCondition();

        } else if(!strcmp(entry_rule_name, "rangeTest")){
            parse_tree = parser.rangeTest();

        } else if(!strcmp(entry_rule_name, "typeTest")){
            parse_tree = parser.typeTest();

        } else if(!strcmp(entry_rule_name, "tryExpression")){
            parse_tree = parser.tryExpression();

        } else if(!strcmp(entry_rule_name, "catchBlock")){
            parse_tree = parser.catchBlock();

        } else if(!strcmp(entry_rule_name, "finallyBlock")){
            parse_tree = parser.finallyBlock();

        } else if(!strcmp(entry_rule_name, "jumpExpression")){
            parse_tree = parser.jumpExpression();

        } else if(!strcmp(entry_rule_name, "callableReference")){
            parse_tree = parser.callableReference();

        } else if(!strcmp(entry_rule_name, "assignmentAndOperator")){
            parse_tree = parser.assignmentAndOperator();

        } else if(!strcmp(entry_rule_name, "equalityOperator")){
            parse_tree = parser.equalityOperator();

        } else if(!strcmp(entry_rule_name, "comparisonOperator")){
            parse_tree = parser.comparisonOperator();

        } else if(!strcmp(entry_rule_name, "inOperator")){
            parse_tree = parser.inOperator();

        } else if(!strcmp(entry_rule_name, "isOperator")){
            parse_tree = parser.isOperator();

        } else if(!strcmp(entry_rule_name, "additiveOperator")){
            parse_tree = parser.additiveOperator();

        } else if(!strcmp(entry_rule_name, "multiplicativeOperator")){
            parse_tree = parser.multiplicativeOperator();

        } else if(!strcmp(entry_rule_name, "asOperator")){
            parse_tree = parser.asOperator();

        } else if(!strcmp(entry_rule_name, "prefixUnaryOperator")){
            parse_tree = parser.prefixUnaryOperator();

        } else if(!strcmp(entry_rule_name, "postfixUnaryOperator")){
            parse_tree = parser.postfixUnaryOperator();

        } else if(!strcmp(entry_rule_name, "excl")){
            parse_tree = parser.excl();

        } else if(!strcmp(entry_rule_name, "memberAccessOperator")){
            parse_tree = parser.memberAccessOperator();

        } else if(!strcmp(entry_rule_name, "safeNav")){
            parse_tree = parser.safeNav();

        } else if(!strcmp(entry_rule_name, "modifiers")){
            parse_tree = parser.modifiers();

        } else if(!strcmp(entry_rule_name, "parameterModifiers")){
            parse_tree = parser.parameterModifiers();

        } else if(!strcmp(entry_rule_name, "modifier")){
            parse_tree = parser.modifier();

        } else if(!strcmp(entry_rule_name, "typeModifiers")){
            parse_tree = parser.typeModifiers();

        } else if(!strcmp(entry_rule_name, "typeModifier")){
            parse_tree = parser.typeModifier();

        } else if(!strcmp(entry_rule_name, "classModifier")){
            parse_tree = parser.classModifier();

        } else if(!strcmp(entry_rule_name, "memberModifier")){
            parse_tree = parser.memberModifier();

        } else if(!strcmp(entry_rule_name, "visibilityModifier")){
            parse_tree = parser.visibilityModifier();

        } else if(!strcmp(entry_rule_name, "varianceModifier")){
            parse_tree = parser.varianceModifier();

        } else if(!strcmp(entry_rule_name, "typeParameterModifiers")){
            parse_tree = parser.typeParameterModifiers();

        } else if(!strcmp(entry_rule_name, "typeParameterModifier")){
            parse_tree = parser.typeParameterModifier();

        } else if(!strcmp(entry_rule_name, "functionModifier")){
            parse_tree = parser.functionModifier();

        } else if(!strcmp(entry_rule_name, "propertyModifier")){
            parse_tree = parser.propertyModifier();

        } else if(!strcmp(entry_rule_name, "inheritanceModifier")){
            parse_tree = parser.inheritanceModifier();

        } else if(!strcmp(entry_rule_name, "parameterModifier")){
            parse_tree = parser.parameterModifier();

        } else if(!strcmp(entry_rule_name, "reificationModifier")){
            parse_tree = parser.reificationModifier();

        } else if(!strcmp(entry_rule_name, "platformModifier")){
            parse_tree = parser.platformModifier();

        } else if(!strcmp(entry_rule_name, "annotation")){
            parse_tree = parser.annotation();

        } else if(!strcmp(entry_rule_name, "singleAnnotation")){
            parse_tree = parser.singleAnnotation();

        } else if(!strcmp(entry_rule_name, "multiAnnotation")){
            parse_tree = parser.multiAnnotation();

        } else if(!strcmp(entry_rule_name, "annotationUseSiteTarget")){
            parse_tree = parser.annotationUseSiteTarget();

        } else if(!strcmp(entry_rule_name, "unescapedAnnotation")){
            parse_tree = parser.unescapedAnnotation();

        } else if(!strcmp(entry_rule_name, "simpleIdentifier")){
            parse_tree = parser.simpleIdentifier();

        } else if(!strcmp(entry_rule_name, "identifier")){
            parse_tree = parser.identifier();

        } else {
            PyErr_SetString(PyExc_ValueError, "Invalid entry_rule_name");
            throw speedy_antlr::PythonException();
        }

        // Translate Parse tree to Python
        SA_KotlinTranslator visitor(&translator);
        result = visitor.visit(parse_tree);

        // Clean up data
        Py_XDECREF(token_module);
        Py_XDECREF(strdata);

        return result;

    } catch(speedy_antlr::PythonException &e) {
        Py_XDECREF(token_module);
        Py_XDECREF(strdata);
        Py_XDECREF(result);

        // Python exception already has error indicator set
        return NULL;
    } catch(...) {
        Py_XDECREF(token_module);
        Py_XDECREF(strdata);
        Py_XDECREF(result);

        // An internal C++ exception was thrown.
        // Set error indicator to a generic runtime error
        PyErr_SetString(PyExc_RuntimeError, "Internal error");
        return NULL;
    }
}


extern "C" {

    static PyObject* c_do_parse(PyObject *self, PyObject *args) {
        return do_parse(self, args);
    }

    static PyMethodDef methods[] = {
        {
            "do_parse",  c_do_parse, METH_VARARGS,
            "Run parser"
        },
        {NULL, NULL, 0, NULL} /* Sentinel */
    };

    static struct PyModuleDef module = {
        PyModuleDef_HEAD_INIT,
        "sa_kotlin_cpp_parser",   /* name of module */
        NULL, /* module documentation, may be NULL */
        -1,       /* size of per-interpreter state of the module,
                    or -1 if the module keeps state in global variables. */
        methods
    };
}


PyMODINIT_FUNC
PyInit_sa_kotlin_cpp_parser(void) {
    PyObject *m = PyModule_Create(&module);
    return m;
}
